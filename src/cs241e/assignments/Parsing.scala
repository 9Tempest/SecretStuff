/*
   Copyright 2020 Ondrej Lhotak. All rights reserved.

   Permission is granted for private study use by students registered in
   CS 241E in the Fall 2020 term.

   The contents of this file may not be published, in whole or in part,
   in print or electronic form.

   The contents of this file may be included in work submitted for CS
   241E assignments in Fall 2020. The contents of this file may not be
   submitted, in whole or in part, for credit in any other course.
*/
package cs241e.assignments

import cs241e.scanparse._
import Grammars._
import DFAs._

import scala.collection.mutable

/** Parsers for general grammars. */

object Parsing {
  /** Parses the `input` sequence of `Token`s according to the `grammar` using the Cocke-Younger-Kasami algorithm.
    * Specifically, the `kind`s of the `Token`s are considered as the terminals of the grammar, and the
    * `lexeme`s are not used for parsing but are preserved in the resulting parse tree.
    *
    * If the parse is ambiguous, returns an arbitrary one of the possible parse trees.
    *
    * If the `input` is not in the language generated by the grammar, returns `None`.
    */
  def parseCYK(grammar: Grammar, input: IndexedSeq[Token]): Option[Tree] = {
    /** The memoization table: if the string of symbols ABC derives the substring of length `length`
      * starting at position `from` of the `input`, then the entry for (Seq("A", "B", "C"), from, length)
      * contains the three parse trees of A, B, and C. If a particular string of symbols
      * does not derive a given substring of the `input`, the corresponding table entry is `None`.
      */
    val memo = mutable.Map[(Seq[String], Int, Int), Option[Seq[Tree]]]()

    /** If the string of symbols `lhs` derives the substring of length `length`
      * starting at position `from` of the `input`, returns a sequence of the parse trees for the
      * symbols in `lhs`.
      *
      * If `lhs` does not derive this substring of the input, returns `None`.
      */
    def recur(lhs: Seq[String], from: Int, length: Int): Option[Seq[Tree]] = {
      if (memo.contains((lhs, from, length))) {
        memo((lhs, from, length))
      }
      else {
        memo((lhs, from, length)) = None
        if (lhs.isEmpty){
          if (length == 0) {
            val ans = Some(Seq())
            memo((lhs, from, length)) = ans
            return ans
          }
          None
        } else if (grammar.terminals.contains(lhs.head)){
          if (from >= input.length) return None
          if (input(from).kind == lhs(0) && recur(lhs.tail, from+1, length-1) != None){
            val ans = Some(recur(lhs.tail, from+1, length-1).get.prepended(new Tree(input(from))))
            memo((lhs, from, length)) = ans
            return ans
          }
          None
        } else if (lhs.length == 1 && grammar.nonTerminals.contains(lhs.head)){
          for (y <- grammar.productionsExpanding(lhs.head)){
            val tempAns = recur(y.rhs, from, length)
            if (tempAns != None) {
              val tempTree = new Tree(Token(lhs.head), tempAns.get)
              val ans = Seq(tempTree)
              memo((lhs, from, length)) = Some(ans)
              return Some(ans)
            }
          }
          None
        } else {
          for (i <- 0 to length){
            val temp1 = recur(Seq(lhs.head), from, i)
            val temp2 = recur(lhs.tail, from+i, length-i)
            if (temp1 != None && temp2 != None){
              val ans = Some(temp1.get ++ temp2.get)
              memo((lhs, from, length)) = ans
              return ans
            }
          }
          None
        }
      }
    }

    recur(Seq(grammar.start), 0, input.size).map(_.head)
  }

  /** Parses the `input` string of terminals according to the `grammar` using Earley's algorithm.
    * Returns `true` if the `input` string is in the language generated by the `grammar`,
    * `false` otherwise.
    *
    * Note: Optional, for bonus only.
    */
  def parseEarley(grammar: Grammar, input: IndexedSeq[String]): Boolean = {
    val memo = mutable.Map[Int, IndexedSeq[(Grammars.Production, Int, Int)]]()
    var currIndex = 0
    def prediction(state: (Grammars.Production, Int, Int), index: Int)={
        for (i <- grammar.productionsExpanding(state._1.rhs(state._2))){
          if (!memo(index).contains(i, 0, index))
          memo(index) = memo(index).appended((i, 0, index))
        }
    }

    def scan(state: (Grammars.Production, Int, Int), index: Int)={
      if (state._3< input.length && state._1.rhs(state._2) == input(index)){
        if (!memo.contains(index+1)) memo(index+1)=IndexedSeq[(Grammars.Production, Int, Int)]()
        memo(index+1) = memo(index+1).appended((state._1, state._2+1, state._3))
      }
    }

    def completion(state: (Grammars.Production, Int, Int), index: Int)={
      for (i <- memo(state._3)){
        if (i._2< i._1.rhs.length &&i._1.rhs(i._2) == state._1.lhs) memo(index) = memo(index).appended((i._1, i._2+1, i._3))
      }
    }
    def startup()={
      memo(0) = IndexedSeq[(Grammars.Production, Int, Int)]()
      for (i <- grammar.productionsExpanding(grammar.start)){
        memo(0) = memo(0).appended((i, 0, 0))
      }
    }

    def mainParse():Boolean={
      startup()
      while(currIndex <= input.length){
        //pprint.pprintln(memo)
        var currInner = 0
        if (!memo.contains(currIndex)) return false
        while (currInner < memo(currIndex).length){
          val dotP = memo(currIndex)(currInner)._2
          val currState = memo(currIndex)(currInner)
          if (currState._2 == currState._1.rhs.length){
            completion(currState, currIndex)
          } else if (grammar.nonTerminals.contains(currState._1.rhs(dotP))){
            prediction(currState, currIndex)
          } else if (grammar.terminals.contains(currState._1.rhs(dotP))){
            scan(currState, currIndex)
          }
          currInner = currInner+1
        }
        currIndex = currIndex+1
      }
      for (i <- memo(input.length)){
        if (i._2 == i._1.rhs.length && i._3 == 0 && i._1.lhs == grammar.start){
          return true
        }
      }
      false
    }
    mainParse()
  }
}
